program = all:(i:statement ws?)* { return _.compile(all.map(i => i[0]))  }

equal = "="
zero  = "0" { return 0 }
digit  = [0-9]
digit_19 = [1-9]
up_to_16 = n:digit { return _.parseInt(n) } / [1] [0-6] { return _.parseInt(text()) }
hex = [0-9a-f]i
hex32 = value:(hex hex space hex hex space hex hex space hex hex) { return text().split(' ').map(_.parseHex) }
decimal = digit_19 digit* { return parseInt(text()) }
number = zero / decimal
int32 = digit_19 digit? digit? digit? digit? digit? digit? digit? { return _.toInt32(_.parseInt(text())) }
byte = "0x" value:(hex hex) { return _.parseInt(text(), 16) }
byte32 = "0x" hex32
false = "false" { return 0; }
true  = "true"  { return 1;  }
ws = [ \t\n\r]*
space = [ ]
spaces =  [ ]+
newline = [\n\r]
quote = "'"
alpha = [a-z]i
alphaOrNumber  = [a-z0-9]i
string = quote chars:[^']* quote { return chars.map(s => s.charCodeAt(0)).concat([0]); }
value_separator = ws? "," ws { return skip() }
variable = "$" name:(alpha alphaOrNumber*) { return _.getOrCreateVarName(name[0] + name[1].join('')); }
variableReference = "$" name:(alpha alphaOrNumber*) { return _.getVarName(name[0] + name[1].join('')); }
pin = "pin " up_to_16 { return _.parseInt(text().replace('pin ', '')) }
pinMode = mode:("input"/"output"/"open drain"/"input pull-up"/"tx"/"rx") { return text() }

statement =
  label / i:instruction instructionEnd { return i } / condition

label = "@" label:(alpha (alpha/digit)* newline?) { return _.createNode('label', text().trim()) }

instructionEnd = spaces? newline / spaces? ";"

instruction =
comment /
halt /
noop /
sysinfo /
variable_assign_int /
variable_assign_byte /
iowrite /
ioread /
iomode /
jumpTo /
jumpIf /
delay /
restart /
debug /
yield /
sysinfo /
dump /
print /
memget /
memset /
unary_operation

variable_assign_int =
  variable:variable spaces equal spaces number:number { return _.opcode([c_push_i, variable, parseInt(number)]) }

variable_assign_byte =
  variable:variable spaces equal spaces byte:byte { return _.opcode([c_push_b, variable, byte]) }

comment =
  "//" space ([^\n])* newline { return _.skip() }

halt =
  "halt" { return _.opcode([c_halt]) }

noop =
  "noop" { return _.opcode([c_noop]) }

sysinfo =
  "sysinfo" { return _.opcode([c_sysinfo]) }

dump =
  "dump" { return _.opcode([c_dump]) }

restart =
  "restart" { return _.opcode([c_restart]) }

yield =
  "yield" { return _.opcode([c_yield]) }

debug =
  "enable logs" { return _.opcode([c_debug]) }

print =
  "print" spaces s:string { return _.opcode([c_print, ...s]) }

iowrite =
  "write" spaces variable:variableReference spaces "to" spaces pin:pin { return _.opcode([c_iowrite, pin, variable]) } /
  "$" pin:up_to_16 spaces "=" spaces variable:variableReference { return _.opcode([c_iowrite, pin, variable]) }

ioread =
  "read" spaces pin:pin spaces "into" spaces variable:variable { return _.opcode([c_ioread, variable, pin]) }

iomode =
  "set" spaces pin:pin spaces "mode to" spaces mode:pinMode { return _.pinMode(pin, mode) }

jumpTo =
  "jump to" spaces label:label { return _.jumpTo(label) }

jumpIf =
  "if" spaces variable:variableReference spaces "jump to" spaces label:label { return _.jumpIf(variable, label) }

delay =
  "wait" spaces time:int32 { return _.opcode([c_delay, ...time]) }

memget =
  variable:variable spaces "=" spaces "[" address:int32 "]" { return _.opcode([c_memget, variable, ...address]) }

memset =
  "[" address:int32 "]" spaces "=" spaces variable:variable { return _.opcode([c_memset, ...address, variable]) }

unary_operation =
    not

not =
  "invert" spaces x:variableReference { return _.opcode([c_not, x]) }

condition =
  "if" comparator "then"

comparator = c:(gt) { return c }

gt =
  "gt" target:variable value_separator a:variable value_separator b:variable { return _.opcode(["if", target, a, b]) }
